from __future__ import annotations

"""File I/O utilities for ChemAssist."""

import io
import zipfile
from typing import Dict, List, Tuple

def create_zip_archive(files: Dict[str, str]) -> bytes:
    """
    Create a ZIP archive from a dictionary of filename -> content.
    
    Args:
        files: Dictionary mapping filename to file content
        
    Returns:
        ZIP archive as bytes
    """
    zip_buffer = io.BytesIO()
    
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        for filename, content in files.items():
            zip_file.writestr(filename, content)
    
    zip_buffer.seek(0)
    return zip_buffer.getvalue()

def create_md_zip_archive(spec, build_mdp_func, build_slurm_func) -> bytes:
    """
    Create a ZIP archive containing all MD input files.
    
    Args:
        spec: MDSpec object with simulation parameters
        build_mdp_func: Function to build .mdp files
        build_slurm_func: Function to build SLURM script
        
    Returns:
        ZIP archive as bytes
    """
    files = {
        "em.mdp": build_mdp_func(spec, "em"),
        "nvt.mdp": build_mdp_func(spec, "nvt"),
        "npt.mdp": build_mdp_func(spec, "npt"),
        "md.mdp": build_mdp_func(spec, "md"),
        "run_md.sh": build_slurm_func(spec),
        "README.md": _create_md_readme(spec)
    }
    
    return create_zip_archive(files)

def create_dft_zip_archive(spec, build_input_func) -> bytes:
    """
    Create a ZIP archive containing DFT input files.
    
    Args:
        spec: JobSpec object with DFT parameters
        build_input_func: Function to build input file
        
    Returns:
        ZIP archive as bytes
    """
    gjf_content = build_input_func(spec)
    files = {
        f"{spec.title.replace(' ', '_')}.gjf": gjf_content,
        "README.md": _create_dft_readme(spec)
    }
    
    return create_zip_archive(files)

def create_md_error_fix_zip_archive(original_mdp: str, fixed_mdp: str, diagnosis: str, stage: str) -> bytes:
    """
    Create a ZIP archive containing MD error fix results.
    
    Args:
        original_mdp: Original problematic .mdp file content
        fixed_mdp: Corrected .mdp file content
        diagnosis: AI diagnosis of the problem
        stage: Simulation stage (em, nvt, npt, md)
        
    Returns:
        ZIP archive as bytes
    """
    files = {
        f"original_{stage}.mdp": original_mdp,
        f"fixed_{stage}.mdp": fixed_mdp,
        f"{stage}_comparison.txt": f"ORIGINAL:\n{original_mdp}\n\nFIXED:\n{fixed_mdp}",
        "diagnosis.txt": diagnosis,
        "README.md": _create_md_error_fix_readme(stage, diagnosis)
    }
    
    return create_zip_archive(files)

def _create_md_readme(spec) -> str:
    """Create a README file for the MD simulation."""
    return f"""# MD Simulation: {spec.title}

## Generated Files
- `em.mdp` - Energy minimization parameters
- `nvt.mdp` - NVT equilibration parameters  
- `npt.mdp` - NPT equilibration parameters
- `md.mdp` - Production MD parameters
- `run_md.sh` - SLURM submission script

## Simulation Parameters
- Temperature: {spec.temperature} K
- Pressure: {spec.pressure} bar
- Time step: {spec.timestep} ps
- Total simulation time: {spec.n_steps * spec.timestep:.1f} ps
- Structure file: {spec.structure_file}
- Topology file: {spec.topology_file}

## Usage
1. Place all files in your simulation directory
2. Ensure {spec.structure_file} and {spec.topology_file} are present
3. Submit the job: `sbatch run_md.sh`
4. Monitor progress: `squeue -u $USER`

## Workflow
1. Energy minimization (em.mdp)
2. NVT equilibration (nvt.mdp) 
3. NPT equilibration (npt.mdp)
4. Production MD (md.mdp)

Generated by ChemAssist v2
"""

def _create_dft_readme(spec) -> str:
    """Create a README file for the DFT calculation."""
    return f"""# DFT Calculation: {spec.title}

## Generated Files
- `{spec.title.replace(' ', '_')}.gjf` - Gaussian input file

## Calculation Parameters
- Method: {spec.method}
- Basis set: {spec.basis}
- Charge: {spec.charge}
- Multiplicity: {spec.multiplicity}
- Title: {spec.title}

## Usage
1. Place the .gjf file in your calculation directory
2. Submit to Gaussian: `g16 < {spec.title.replace(' ', '_')}.gjf > {spec.title.replace(' ', '_')}.log`
3. Monitor progress: Check the .log file

## File Format
- Gaussian 16 input format (.gjf)
- Compatible with G16, G09, and other Gaussian versions
- Contains optimized parameters for the specified method/basis

Generated by ChemAssist v2
"""

def _create_md_error_fix_readme(stage: str, diagnosis: str) -> str:
    """Create a README file for MD error fix results."""
    return f"""# MD Error Fix: {stage.upper()} Stage

## Generated Files
- `original_{stage}.mdp` - Original problematic .mdp file
- `fixed_{stage}.mdp` - Corrected .mdp file ready to use
- `{stage}_comparison.txt` - Side-by-side comparison
- `diagnosis.txt` - AI diagnosis of the problem

## Problem Diagnosis
{diagnosis}

## Usage
1. Use `fixed_{stage}.mdp` for your simulation
2. Compare with `original_{stage}.mdp` to see what was changed
3. Check `diagnosis.txt` for detailed explanation
4. Run your simulation with the corrected file

## Simulation Stage
- Stage: {stage.upper()}
- File type: GROMACS .mdp parameter file
- Status: Fixed and ready to use

## Next Steps
1. Replace your original .mdp file with the fixed version
2. Run your GROMACS simulation
3. Monitor the new .log file for any remaining issues

Generated by ChemAssist v2 MD Error Fixer
"""
